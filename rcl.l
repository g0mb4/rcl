%{	/* user defined code needed for the rules */

#include <string.h>

#include "rcl.h"
#include "rcl.tab.h"	/* generated by bison for the return values */

/* prototypes */
char *strdupwoquotes(const char * s);
uint8_t bin2int(const char * s);
uint8_t hex2int(const char * s);

%} /* end of the user defined code */

/* flex definitions */

/* use line numbers */
%option yylineno
/* don't generate input() */
%option noinput
/* don't generate yyunput() */
%option nounput

/* regex pattern definitions */
CHARS		[[:print:]]
DIGITS 		[0-9]
INT	 		[-+]?{DIGITS}+
DBL 		{INT}\.{DIGITS}+
STR			[\"]{CHARS}+[\"]
ATTR        [a-zA-Z_][0-9a-zA-Z_]*
BININT		0[bB][0-1]+
HEXINT		0[xX][0-9a-fA-F]+

%%	/* start of the rules */

{STR}		{	yylval.rcl_val = rcl_string(strdupwoquotes(yytext));	/* string */
				return VALUE; }
{INT}  		{	yylval.rcl_val = rcl_number((double)atoi(yytext));	/* integer */
				return VALUE; }
{DBL}  		{	yylval.rcl_val = rcl_number(atof(yytext));	/* double */
				return VALUE; }
{BININT}	{	yylval.rcl_val = rcl_byte(bin2int(yytext));	/* binary integer */
				return VALUE; }
{HEXINT}	{	yylval.rcl_val = rcl_byte(hex2int(yytext));	/* binary integer */
				return VALUE; }
"true"		{	yylval.rcl_val = rcl_boolean(true);	/* bool */
				return VALUE; }
"false"		{	yylval.rcl_val = rcl_boolean(false);	/* bool */
				return VALUE; }

"get"		{	yylval.i = OP_GET;
				return OPERATOR; 	}
"set"		{ 	yylval.i = OP_SET;
				return OPERATOR;	}
"reset"		{ 	yylval.i = OP_RESET;
				return OPERATOR;	}
"start"		{	yylval.i = OP_START;
				return OPERATOR;	}
"stop"		{	yylval.i = OP_STOP;
				return OPERATOR;	}

{ATTR}		{  yylval.s = strdup(yytext);
			   return ATTRIBUTE;	}

\[ 			{	return L_BEGIN;	}			/* list start */
\] 			{	return L_END; 	}			/* list end */
, 			{	return COMMA; 	}			/* list separator */

\n			{	return NLINE;	}			/* new line */
[ \t\r]+ 	{ 	; } 						/* ignore whitespaces */
. 			{	return UNKNOWN; }			/* every other chars */

%% 	/* end of the rules */

/* user defined code */

/* returns an unquoted string
 */
char *strdupwoquotes(const char * s){
	int i, j = 0, len = strlen(s);

	/*  empty string */
	if(len <= 2){
		return NULL;
	}

	char * d = malloc(strlen(s) - 1);   /* lenght - 2 quotes + 1 terminator */

   	if (d == NULL)
		return NULL;

	for(i = 1; i < (len - 1); i++){
		d[j++] = s[i];
	}
	d[j] = '\0';

   	return d;
}

/* converts a binary string into a number
 */
uint8_t bin2int(const char * s){
	return (uint8_t)strtol((s + 2), NULL, 2);	// skip "0b"
}

/* converts a hex string into a number
 */
uint8_t hex2int(const char * s){
	return (uint8_t)strtol((s + 2), NULL, 16); // skip "0x"
}

/* for the compiler
 */
int yywrap(void){
   return 1;
}
